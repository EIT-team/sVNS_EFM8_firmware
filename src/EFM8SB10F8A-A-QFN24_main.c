//=========================================================
// src/EFM8SB10F8A-A-QFN24_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <si_toolchain.h>
#include <SI_EFM8SB1_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
#include "EFM8SB1_SMBus_Master_Multibyte.h"
#include "power.h"
#include "SmaRTClock.h"
#include "adc_0.h"

// $[Generated Includes]
// [Generated Includes]$

//-----------------------------------------------------------------------------
// Application-component specific constants and variables
//-----------------------------------------------------------------------------

// Stimulation parameters
// P0.7 - IREF
// Read from NFC:
uint8_t PW_HB;          // Pulse width high byte, chunks of 50 us, where 1 = 50 us, 2 = 100 us, 3 = 150 us
uint8_t PW_LB;          // Pulse width low byte
uint16_t PW;            // Pulse width 16-bit word
uint8_t F_hz_HB;        // Pulse frequency high byte, Hz
uint8_t F_hz_LB;        // Pulse frequency low byte, Hz
uint16_t F_hz;          // Pulse frequency 16-bit word, Hz
uint8_t Iset;           // Set IREF current reference value, 0-63 (decimal) / 0 - 3F (hex)
uint8_t mode;           // Stimulation mode. 1 for multichannel scan, 2 for singlechannel uninterrupted stimulation
uint8_t channel_nr;     // Preset channel number for the single-channel stimulation
// uint8_t T_on;           // Stimulation time on and off, seconds
uint8_t T_on_alarm_0;
uint8_t T_on_alarm_1;
uint8_t T_on_alarm_2;
bool On;                // Voltage converter and 20V plane switch -> Switches stimulation circuit
// uint8_t Protocol;       // Protocol type, 0 - Biphasic pulmonary, 1 - Biphasic laryngeal, 2 - Biphasic general uninterrupted, 3 - Monophasic
// Used in workflow:
bool isStim = 0;        // Stimulation on/off status for the sleep mode initiation

// Stimulation function prototypes
void Polarity(uint8_t);
void T0_Waitus (uint8_t);
void T3_init(uint8_t, uint8_t);
void Pulse_On(void);
void Pulse_Off(void);
void Biphasic_protocol(void);
void Biphasic_protocol_single_channel(void);
uint8_t getByte (uint16_t, uint8_t);
void RTC_alarm_set (uint8_t,uint8_t,uint8_t);


// I2C
// P0.0 - SMBus SDA
// P0.1 - SMBus SCL
uint8_t j;                                  // Counter variable
uint8_t SMB_DATA_OUT[NUM_BYTES_WR] = {0};   // Initialize I2C Write buffer, fill with 0
uint8_t SMB_DATA_IN[NUM_BYTES_RD] = {0};    // Initialize I2C Read buffer, fill with 0
uint8_t SAVE[16];                           // Saved Read array
uint8_t TARGET;                             // Target SMBus slave address
//define TARGET SLAVE_ADDR
volatile bool SMB_BUSY;                     // SMB status bit
volatile bool SMB_RW;                       // SMB status bit
uint16_t NUM_ERRORS;
SI_SBIT (SDA, SFR_P0, 0);                   // SMBus on P0.0
SI_SBIT (SCL, SFR_P0, 1);                   // and P0.1

// I2C function prototypes
void SMB_Write (void);
void SMB_Read (void);
void SDA_Reset(void);
void Write_Channel(uint8_t);

// LT8410, MUX36 shutdown pin
SI_SBIT (P05, SFR_P0, 5);                   // Pin 0.5 for SHDN (20V stage) enable/disable

// MUX36S16 - H-bridge multiplexer, pins 1.4 - 1.7
SI_SBIT (P17, SFR_P1, 7);                   // Pin 1.7 for MUX36S16 A0
SI_SBIT (P16, SFR_P1, 6);                   // Pin 1.6 for MUX36S16 A1
SI_SBIT (P15, SFR_P1, 5);                   // Pin 1.5 for MUX36S16 A2
SI_SBIT (P14, SFR_P1, 4);                   // Pin 1.4 for MUX36S16 A3
uint8_t mux36s16_state = 0;                 // MUX36S16 state byte
// MUX36S16 state function
void MUX36S16_output(uint8_t);
// Channel check function due to the skipped MUX36S16 channel S14A and S14B
void check_channel();

// MUX36D08 - multiplexer for output channels, pins 0.2 - 0.4
SI_SBIT (P02, SFR_P0, 2);                   // Pin 0.2 for MUX36D08 A0
SI_SBIT (P03, SFR_P0, 3);                   // Pin 0.3 for MUX36D08 A1
SI_SBIT (P04, SFR_P0, 4);                   // Pin 0.4 for MUX36D08 A2
uint8_t mux36d08_state;                     // MUX36D08 state byte
// MUX36D08 state function
void MUX36D08_output(uint8_t);

// ADC
void sampleADC(void);
#define VREF_MV         (1650UL)      // Configured voltage reference, 1.65 V for the ADC
#define ADC_MAX_RESULT  ((1 << 10)-1) // ADC resolution, 10 bit ADC
uint16_t ADC0_convertSampleToMillivolts(uint16_t); // ADC sample conversion to mV

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void
SiLabs_Startup (void)
{
// $[SiLabs Startup]
// [SiLabs Startup]$
}

//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
void
main (void)
{
  T0_Waitus(1);                     // Wait 50 us for stability
  // SMBus reset mode in case of I2C comms SDA fault
  enter_smbus_reset_from_RESET ();
  while(!SDA){
      SDA_Reset();
  }

  // Initialize normal operation
  enter_DefaultMode_from_smbus_reset ();

  // Initialize RTC and power management.
  RTC0CN0_Local = 0xC0;                // Initialize Local Copy of RTC0CN0
  RTC0CN0_SetBits(RTC0TR+RTC0AEN+ALRM);// Enable Counter, Alarm, and Auto-Reset
  LPM_Init();                         // Initialize Power Management
  LPM_Enable_Wakeup(RTC);             // RTC alarm as the Wake Up source
  RTC_Alarm = 1;                      // Set the RTC Alarm Flag on startup

  // Read data-stimulation parameters from NT3H via I2C
  TARGET = SLAVE_ADDR;         // NT3H slave address, 0xAA for NT3H
  SMB_Read();                  // Read first 16 bytes from the memory 0x01 into READ buffer
  for(j=0; j<16; j++){
      SAVE[j] = SMB_DATA_IN[j];   // Save read buffer into array
  }
  PW_HB = SAVE[0]; // Pulse Width in chunks of 50 us high byte
  PW_LB = SAVE[1]; // Pulse Width in chunks of 50 us low byte
  F_hz_HB = SAVE[2]; // Pulse frequency high byte
  F_hz_LB = SAVE[3]; // Pulse frequency low byte
  T_on_alarm_0 = SAVE[4];    // Stimulation protcol time on/off
  T_on_alarm_1 = SAVE[5];
  T_on_alarm_2 = SAVE[6];
  On = SAVE[7];
  PW = (PW_HB<<8)|(PW_LB); // Combine PW into single hex
  F_hz = (F_hz_HB<<8)|(F_hz_LB); // Combine IPW into single hex
  Iset = SAVE[8];     // IREF current value, remember 0x3F is maximum, 0.5 mA reference current
  mode = SAVE[9];     // Stimulation mode. 1 - Channel scanning; 2 - Single channel stimulation
  channel_nr = SAVE[10];
  check_channel(); // checks if user wants channel 14 or 15 (channel 14 is skipped in MUX36S16)
  // Set the device according to read values
  P05 = On;              // Enable or disable LT8410, enable MUX36D08 and 2x MUX36S16

  // Initialize timer 3 overflow/interrupts with the set frequency
  T3_init(F_hz_HB,F_hz_LB);            // Remember, 0x5D3D is 20 Hz, 0x5D is HB, 0x3D is LB
  // Set duty cycle using RTC
  RTC_alarm_set(T_on_alarm_0, T_on_alarm_1,T_on_alarm_2);
      // Remember, for proper laryngeal timing (5 sec on, 5 sec off) alarm0 = 00, alarm1 = 0x70, alarm2 = 0x02

  TMR3CN0 |= TMR3CN0_TR3__RUN; // start timer 3 for stimulation
  while(1){
      if (mode == 1) {
          Biphasic_protocol();
      }
      else if (mode == 2) {
          Biphasic_protocol_single_channel();
      }
  };
}

// Function definitions

void Polarity(char polar) {
  switch (polar) {
  case 1: // Forward polarity
    MUX36D08_output(0x01);
    break;
  case 2: // Reversed polarity
    MUX36D08_output(0x02);
    break;
  case 0: // Shunted
    MUX36D08_output(0x00);
    break;
  }
}

/*
 * Function: Pulse_On
 * --------------------
 * Activates current reference at P0.7.
 * Reads amplitude bit from SMBus as Iset.
 */
void Pulse_On(void){
  IREF0CN0 = IREF0CN0_SINK__DISABLED | IREF0CN0_MDSEL__HIGH_CURRENT
                        | (Iset << IREF0CN0_IREF0DAT__SHIFT);
}

void Pulse_Off(void){
  IREF0CN0 = IREF0CN0_SINK__DISABLED | IREF0CN0_MDSEL__HIGH_CURRENT
                            | (0x00 << IREF0CN0_IREF0DAT__SHIFT); // Current 0 mA
}

/* Function: T0_Waitus
 * --------------------
 * Wait function based on timer 0 overflow.
 * Overflows every 50 us. Does not generate interrupt.
 */
void T0_Waitus (uint8_t us)
{
   TCON &= ~0x30;                      // Stop Timer0; Clear TCON_TF0
   TMOD &= ~0x0f;                      // 16-bit free run mode
   TMOD |=  0x01;

   CKCON0 |= 0x04;                      // Timer0 counts SYSCLKs

   while (us) {
      TCON_TR0 = 0;                         // Stop Timer0
      //TH0 = ((-SYSCLK/1000) >> 8);     // Overflow in 1ms
      // Overflow in 0xFC18 (64536) cycles, which for the 20 MHz is 50 us.
      TH0 = 0xFE;
      //TL0 = ((-SYSCLK/1000) & 0xFF);
      TL0 = 0x0C;
      TCON_TF0 = 0;                         // Clear overflow indicator
      TCON_TR0 = 1;                         // Start Timer0
      while (!TCON_TF0);                    // Wait for overflow
      us--;                            // Update us counter
   }

   TCON_TR0 = 0;                            // Stop Timer0
}

// Function: T3_init
// * --------------------
// * Intializes timer 3 to generate interrupts according to required frequency.
//
void T3_init(uint8_t freq_H, uint8_t freq_L){
  // Save Timer Configuration
  uint8_t TMR3CN0_TR3_save;
  TMR3CN0_TR3_save = TMR3CN0 & TMR3CN0_TR3__BMASK;
  // Stop Timer
  TMR3CN0 &= ~(TMR3CN0_TR3__BMASK);
  // Initialize the timer
  // Set high and low bytes to 0xFF
  TMR3H = (0xFF << TMR3H_TMR3H__SHIFT);
  TMR3L = (0xFF << TMR3L_TMR3L__SHIFT);
  // Set high and low overflow reload bytes
  TMR3RLH = (freq_H << TMR3RLH_TMR3RLH__SHIFT);
  TMR3RLL = (freq_L << TMR3RLL_TMR3RLL__SHIFT);
  // Restore Timer Configuration
  TMR3CN0 |= TMR3CN0_TR3_save;
}

// Function: Biphasic_protocol
// * --------------------
// * Biphasic stimulation with the pulmonary/laryngeal protocol
//
void Biphasic_protocol(void){
  MUX36S16_output(0);
  while(1){
      // Handle RTC failure
      if(RTC_Failure)
      {
       RTC_Failure = 0;              // Reset RTC Failure Flag to indicate
                       // that we have detected an RTC failure
                       // and are handling the event
       // Do something...RTC Has Stopped Oscillating
       while(1);                     // <Insert Handler Code Here>
      }
      // Handle RTC Alarm
      if(RTC_Alarm)
          {
           RTC_Alarm = 0;                // Reset RTC Alarm Flag to indicate
                           // that we have detected an alarm
                           // and are handling the alarm event
           isStim = !isStim;       // Change stimulation state
          }
      // Stimulation state. Stay awake.
      if (isStim) {
        MUX36S16_output(mux36s16_state);
        Write_Channel(mux36s16_state);
        while((PMU0CF & RTCAWK) == 0); // Wait for next alarm or clock failure, then clear flags
        // Initiate interrupts. Interrupts in process until the next RTC alarm
        if(PMU0CF & RTCAWK) RTC_Alarm = 1;
        if(PMU0CF & RTCFWK) RTC_Failure = 1;
        PMU0CF = 0x20;
        if ((mux36s16_state < 16)){
            mux36s16_state ++;
            if (mux36s16_state == 13){
                mux36s16_state = 14;
            }
        }
        else {
            mux36s16_state = 0;
        }
      }
      else {
          // Interburst state. Place the device into the sleep mode
          LPM(SLEEP);  // Enter Sleep Until Next Alarm
      }
    }
}

// Function: Biphasic_protocol_single_channel
// * --------------------
// * Uninterrupted single channel biphasic stimulation
// * with the pulmonary/laryngeal protocol
//
void Biphasic_protocol_single_channel(void)
{
  while(1){
      // Handle RTC failure
      if(RTC_Failure)
      {
       RTC_Failure = 0;              // Reset RTC Failure Flag to indicate
                       // that we have detected an RTC failure
                       // and are handling the event
       // Do something...RTC Has Stopped Oscillating
       while(1);                     // <Insert Handler Code Here>
      }
      // Handle RTC Alarm
      if(RTC_Alarm)
          {
           RTC_Alarm = 0;                // Reset RTC Alarm Flag to indicate
                           // that we have detected an alarm
                           // and are handling the alarm event
           isStim = !isStim;       // Change stimulation state
          }
      // Stimulation state. Stay awake.
      if (isStim) {
        MUX36S16_output(channel_nr);
        while((PMU0CF & RTCAWK) == 0); // Wait for next alarm or clock failure, then clear flags
        // Initiate interrupts. Interrupts in process until the next RTC alarm
        if(PMU0CF & RTCAWK) RTC_Alarm = 1;
        if(PMU0CF & RTCFWK) RTC_Failure = 1;
        PMU0CF = 0x20;
      }
      else {
          // Interburst state. Place the device into the sleep mode
          LPM(SLEEP);  // Enter Sleep Until Next Alarm
      }
    }
}

void SDA_Reset(void)
{
    uint8_t j;                    // Dummy variable counters
    // Provide clock pulses to allow the slave to advance out
    // of its current state. This will allow it to release SDA.
    XBR1 = 0x40;                     // Enable Crossbar
    SCL = 0;                         // Drive the clock low
    for(j = 0; j < 255; j++);        // Hold the clock low
    SCL = 1;                         // Release the clock
    while(!SCL);                     // Wait for open-drain
                     // clock output to rise
    for(j = 0; j < 10; j++);         // Hold the clock high
    XBR1 = 0x00;                     // Disable Crossbar
}

void SMB_Write (void)
{
  while (SMB_BUSY);                   // Wait for SMBus to be free.
   SMB_BUSY = 1;                       // Claim SMBus (set to busy)
   SMB_RW = 0;                         // Mark this transfer as a WRITE
   SMB0CN0_STA = 1;                            // Start transfer

   while (SMB_BUSY);
}

void SMB_Read (void)
{
  while (SMB_BUSY);               // Wait for bus to be free.
   SMB_BUSY = 1;                       // Claim SMBus (set to busy)
   SMB_RW = 1;                         // Mark this transfer as a READ
   SMB0CN0_STA = 1;                            // Start transfer

   while (SMB_BUSY);               // Wait for transfer to complete
}

/*
 * Function: MUX36S16_output
 * -------------------------------
 * MUX36D08 output selection function
 * Selects output channel of the stimulation.
 *
 * mux36s16_state:switch state read from NT3H.
 * Switch state converted to corresponding bits that are set as control pins for MUX36
 * as per MUX36 truth table.
 * MUX36S16 truth table:
 * EN A3 A2 A1 A0 ON-CHANNEL
 * 0  X  X  X  X  All channels are off
 * 1 0 0 0 0 Channel 1
 * 1 0 0 0 1 Channel 2
 * 1 0 0 1 0 Channel 3
 * 1 0 0 1 1 Channel 4
 * 1 0 1 0 0 Channel 5
 * 1 0 1 0 1 Channel 6
 * 1 0 1 1 0 Channel 7
 * 1 0 1 1 1 Channel 8
 * 1 1 0 0 0 Channel 9
 * 1 1 0 0 1 Channel 10
 * 1 1 0 1 0 Channel 11
 * 1 1 0 1 1 Channel 12
 * 1 1 1 0 0 Channel 13
 * 1 1 1 0 1 Channel 14
 * 1 1 1 1 0 Channel 15
 * 1 1 1 1 1 Channel 16
 */
void MUX36S16_output(uint8_t mux36s16_state){
  P17 = (mux36s16_state & (1 << (1-1))) ? 1 : 0; // Get 1st bit of MUX36S16 state byte
  P16 = (mux36s16_state & (1 << (2-1))) ? 1 : 0; // Get 2nd bit of the state byte
  P15 = (mux36s16_state & (1 << (3-1))) ? 1 : 0; // Get 3rd bit of the state byte
  P14 = (mux36s16_state & (1 << (4-1))) ? 1 : 0; // Get 4th bit of the state byte
}

/*
 * Function: check_channel
 * -----------------------
 * Because channel 14 for the output MUX36S16 is skipped,
 * channel numbers are shifted by one for the channel 14 (decimal code 13, hex D) and 15
 * (decimal code 14, hex E). Calibrate that such that user can input standard channels
 * according to the channel cuff enumeration.
 */
void check_channel()
{
  if (channel_nr >= 13){
      channel_nr = channel_nr + 1;
  }
}

/*
 * Function: MUX36D08_output
 * -------------------------------
 * MUX36D08 output selection function
 * Selects output channel of the stimulation.
 *
 * mux36d08_state:switch state read from NT3H.
 * Switch state converted to corresponding bits that are set as control pins for MUX36
 * as per MUX36 truth table.
 * MUX36D08 truth table:
 * EN A2  A1  A0  ON-CHANNEL
 * 0  X   X   X   All channels are off
 * 1  0   0   0   Channels 1A and 1B
 * 1  0   0   1   Channels 2A and 2B
 * 1  0   1   0   Channels 3A and 3B
 * 1  0   1   1   Channels 4A and 4B
 * 1  1   0   0   Channels 5A and 5B
 * 1  1   0   1   Channels 6A and 6B
 * 1  1   1   0   Channels 7A and 7B
 * 1  1   1   1   Channels 8A and 8B
 */
void MUX36D08_output(uint8_t mux36d08_state){
  P02 = (mux36d08_state & (1 << (1-1))) ? 1 : 0; // Get 1st bit of MUX36D08 state byte
  P03 = (mux36d08_state & (1 << (2-1))) ? 1 : 0; // Get 2nd bit of the state byte
  P04 = (mux36d08_state & (1 << (3-1))) ? 1 : 0; // Get 3rd bit of the state byte
}

/*
 * Function: getByte
 * Takes the integer number and the byte number of interest
 * Returns the N-th byte of the integer. First byte starts at 0, i.e.
 * For the LSB byte (LB) N = 0, for the second byte (MSB) N =1.
 */
uint8_t
getByte (uint16_t number, uint8_t N)
{
  uint8_t x = (number >> (8 * N)) & 0xff;
  return x;
}

/*
 * Function: RTC_alarm_set
 * Sets pulse frequency as RTC alarm to wake up the MCU at pulse generation time
 * time - low byte of the frequency hexadecimal value
 */
void
RTC_alarm_set (uint8_t alarm_0, uint8_t alarm_1, uint8_t alarm_2)
{
  // Conversion to the RTC alarm value

  // Frequency implementation, the frequency is argument of the function

  //  uint16_t F_alarm_value;
  //  F_alarm_value = 16384 / freq_Hz; // Test value
  //  16384 is the RTC low time oscillator. However, the RTC LFosc behaves like 32768 counter. (see RTC reference manual)
  //  F_alarm_value = 32768 / freq_Hz;

  // Time implementation, the time is argument of the function

  //  16384 is the RTC low time oscillator. However, the RTC LFosc behaves like 32768 counter. (see RTC reference manual)
  //  F_alarm_value = 32768 / (1/time); //

  // Get high and low bytes of F_alarm_value:
  //  alarm0 = getByte (F_alarm_value, 0);
  //  alarm1 = getByte (F_alarm_value, 1);
  //  alarm2 = getByte (F_alarm_value, 2);

  // Re-set the RTC according to new values
  // RTC oscillator control

  RTC0ADR = RTC0XCN0;
  RTC0DAT = RTC0XCN0_XMODE__SELF_OSCILLATE | RTC0XCN0_AGCEN__DISABLED
      | RTC0XCN0_BIASX2__DISABLED | RTC0XCN0_LFOEN__ENABLED;
  while ((RTC0ADR & RTC0ADR_BUSY__BMASK) == RTC0ADR_BUSY__SET)
    ;
  // Program RTC alarm value 0 - ms
  RTC0ADR = ALARM0;
  RTC0DAT = (alarm_0 << ALARM0_ALARM0__SHIFT);
  while ((RTC0ADR & RTC0ADR_BUSY__BMASK) == RTC0ADR_BUSY__SET)
    ;
  // Program RTC alarm value 1  - sec1, "LB"
  RTC0ADR = ALARM1;
  RTC0DAT = (alarm_1 << ALARM1_ALARM1__SHIFT);
  while ((RTC0ADR & RTC0ADR_BUSY__BMASK) == RTC0ADR_BUSY__SET)
    ;
  // Program RTC alarm value 2  - sec2, "HB"
  RTC0ADR = ALARM2;
  RTC0DAT = (alarm_2 << ALARM2_ALARM2__SHIFT);
  while ((RTC0ADR & RTC0ADR_BUSY__BMASK) == RTC0ADR_BUSY__SET)
    ;    //Poll Busy Bit

  // RTC control. Prepare and start the RTC
  RTC0ADR = RTC0CN0;
  RTC0DAT = RTC0CN0_RTC0EN__ENABLED | RTC0CN0_RTC0TR__RUN
      | RTC0CN0_MCLKEN__ENABLED | RTC0CN0_RTC0AEN__ENABLED | RTC0CN0_ALRM__SET
      | RTC0CN0_RTC0CAP__NOT_SET | RTC0CN0_RTC0SET__NOT_SET;
  while ((RTC0ADR & RTC0ADR_BUSY__BMASK) == RTC0ADR_BUSY__SET)
    ;    //Poll Busy Bit
}

/*
 * Function: Write_Channel
 * -----------------------
 * For the multichannel stimulation writes the current channel number to NT3H
 * (Address 8 on the NFC Tools GUI)
 */
void Write_Channel(uint8_t channel_to_write)
{
  if (channel_to_write >= 14){
      channel_to_write = channel_to_write - 1; // Because in the MUX36S16 wiring channel 14 is skipped, in the multichannel scanning mode, channel 14 is skipped
      // and wired to channel 15, but for the user who has just the cuff it is irrelevant and unnecessary to know, hence write on the NFC channel 14 as "14" (decimal 13/hex D).
  }
  SMB_DATA_OUT[0] = channel_to_write;
  TARGET = SLAVE_ADDR;
  SMB_Write();                     // Initiate SMBus write
}

void sampleADC(void)
{
  uint16_t mV; uint8_t mV1; uint8_t mV2;
  //uint8_t SMB_DATA_OUT[3];
  ADC0_startConversion();
  while(!ADC0_isConversionComplete()); // Wait for conversion to complete
  mV = ADC0_convertSampleToMillivolts(ADC0_getResult());
  mV1 = getByte(mV,0);
  mV2 = getByte(mV,1);
  SMB_DATA_OUT[0] = 0x00;
  SMB_DATA_OUT[1] = mV1;
  SMB_DATA_OUT[2] = mV2;
  TARGET = SLAVE_ADDR;         // I2C slave address for NT3H is 0xAA
  SMB_Write();                     // Initiate SMBus write
}

uint16_t ADC0_convertSampleToMillivolts(uint16_t sample)
{
  // The measured voltage applied to P1.7 is given by:
  //
  //                           Vref (mV)
  //   measurement (mV) =   --------------- * result (bits)
  //                       (2^10)-1 (bits)
  return ((uint32_t)sample * VREF_MV) / ADC_MAX_RESULT;
}
