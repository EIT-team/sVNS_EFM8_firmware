//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8SB1_Register_Enums.h>
#include "EFM8SB1_SMBus_Master_Multibyte.h"
#include "adc_0.h"

extern void
Polarity (uint8_t);
extern void
Pulse_On (void);
extern void
Pulse_Off (void);
extern void
T0_Waitus (uint8_t); // waits 50 us
extern uint16_t PW;

// ADC
bool ADC_CONVERSION_COMPLETE = false;
extern void
sampleADC (void);

// NT3H I2C parameters
#define MEMA_read  0x01     // Memory address to read
#define MEMA_write  0x02    // Memory address to write
bool SA_sent = 0;
bool SA_read_sent = 0;
bool MEMA_sent = 0;
bool Read_Init = 0;

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// Modified SMBUS communication protocol for I2C communication with NT3H2211.
// Read/Write compatible. Modified by Ed.
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(SMBUS0_ISR, SMBUS0_IRQn)
  {
    bool FAIL = 0;                       // Used by the ISR to flag failed
    // transfers

    static uint8_t sent_byte_counter;
    static uint8_t rec_byte_counter;

    if (SMB0CN0_ARBLOST == 0)// Check for errors
      {
        // Normal operation
        switch (SMB0CN0 & 0xF0)// Status vector
          {
            // Master Transmitter/Receiver: START condition transmitted.
            case SMB_MTSTA:
            SMB0DAT = TARGET;// Load address of the target slave
            SMB0DAT &= 0xFE;// Clear the LSB of the address for the
            // R/W bit
            if (SMB_RW == READ && Read_Init)
              { // Prepare the read mode
                SMB0DAT |= (uint8_t) 1;// set 1 as per NT3H manual for DATA IN receive
                SMB0CN0_STA = 0;// Manually clear START bit
                SA_read_sent = 1;
              }
            else
              {
                SMB0DAT |= (uint8_t) 0; // set 0 as per NT3H manual
                SMB0CN0_STA = 0;// Manually clear START bit
              }
            rec_byte_counter = 1; // Reset the counter
            sent_byte_counter = 1;// Reset the counter
            SA_sent = 1;
            break;

            // Master Transmitter: Data byte transmitted
            case SMB_MTDB:
//            if (SMB0CN0_ACK && SA_sent && MEMA_sent)// Slave SMB0CN0_ACK?
            if (SMB0CN0_ACK && SA_sent && MEMA_sent == 0)
              {
                if (SMB_RW == WRITE)
                  {
                    SMB0DAT = MEMA_write;
                    MEMA_sent = 1;
                  }
                else
                  {
                    SMB0DAT = MEMA_read;
                    MEMA_sent = 1;
                    Read_Init = 0;
                  }
                break;
              }
            else if (SMB0CN0_ACK && SMB_RW == WRITE && MEMA_sent) // If this transfer is a WRITE, and memory address has been sent
              {
                if (sent_byte_counter <= NUM_BYTES_WR)
                  {
                    // send data byte
                    SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                    sent_byte_counter++;
                  }
                else // End of writing
                  {
                    SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
                    SMB_BUSY = 0;// And free SMBus interface
                    MEMA_sent = 0;
                    SA_sent = 0;
                  }
              }
            else if (SMB0CN0_ACK && SMB_RW == READ && MEMA_sent && Read_Init == 0) // If transfer is read, initiate STOP, then START, then first 7 bits of SA
            // then proceed to receive mode
              {
                SMB0CN0_STO = 1;
                SMB0CN0_ACK = 1;
                Read_Init = 1;
                SMB0CN0_STA = 1;
              }
            else if (SMB0CN0_ACK == 0)                     // If slave NACK,
              {
                SMB0CN0_STO = 1;                // Send STOP condition, followed
                SMB0CN0_STA = 1;// By a START
                NUM_ERRORS++;// Indicate error. Useful for debugging if SMBus is stuck.
              }
            break;

            // Master Receiver: byte received
            case SMB_MRDB:
            if (rec_byte_counter < NUM_BYTES_RD)
              {
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
                // byte
                SMB0CN0_ACK = 1;// Send SMB0CN0_ACK to indicate byte received
                rec_byte_counter++;// Increment the byte counter
              }
            else // End of reading
              {
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
                // byte
                SMB_BUSY = 0;// Free SMBus interface
                //SMB0CN0_ACK = 0;// Send NACK to indicate last byte
                // of this transfer
                SMB0CN0_ACK = 1;// Send SMB0CN0_ACK to indicate byte received

                SMB0CN0_STO = 1;// Send STOP to terminate transfer
                MEMA_sent = 0;
                SA_sent = 0;
                Read_Init = 0;
                SA_read_sent = 0;
              }
            break;

            default:
            FAIL = 1;                  // Indicate failed transfer
            // and handle at end of ISR
            break;

          } // end switch
      }
    else
      {
        // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
        FAIL = 1;
      } // end SMB0CN0_ARBLOST if

    if (FAIL)// If the transfer failed,
      {
        SMB0CF &= ~0x80;                 // Reset communication
        SMB0CF |= 0x80;
        SMB0CN0_STA = 0;
        SMB0CN0_STO = 0;
        SMB0CN0_ACK = 0;

        SMB_BUSY = 0;// Free SMBus

        FAIL = 0;
//       LED0 = 0;

        NUM_ERRORS++;// Indicate an error occurred
      }
    SMB0CN0_SI = 0;                             // Clear interrupt flag
  }

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
// Biphasic pulse sequence when the pulse frequency timer (Timer 3) overflows 
// and initiates ISR
SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
  {
    Polarity(0); // start shunted
    Polarity(1);// Forward polarity
    Pulse_On();
    T0_Waitus(PW);
    // (-) phase for next 50 us
    Pulse_Off();
    // Shunt and reverse
    Polarity(0);// Shunted
    Polarity(2);// Reverse
    Pulse_On();
    T0_Waitus(PW);
    // (+) phase for next 50 us
    // 100 us passed, stop stimulation
    Polarity(0);// Shunted
    Pulse_Off();
    // Sample op amp output
    // sampleADC();
    TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending flag
  }

SI_INTERRUPT(TIMER2_ISR, TIMER2_IRQn)
  {
    TMR2CN0_TF2H = 0;                             // clear Timer2 interrupt flag

  }
//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
  {
  ADC0_clearIntFlags(ADC0_CONVERSION_COMPLETE_IF);
  ADC_CONVERSION_COMPLETE = true;
  }

